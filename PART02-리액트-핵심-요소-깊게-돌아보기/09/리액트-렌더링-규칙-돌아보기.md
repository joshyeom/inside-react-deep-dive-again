 ## 렌더링 조건

 1. **최초 렌더링**: 애플리케이션이 처음 로드될 때
 2. **상태 변경**: `useState()`의 상태 변경 함수나 `useReducer()`의 디스패처 함수가 호출될 때
 3. **부모 컴포넌트의 리렌더링**: 부모 컴포넌트가 렌더링되면, 자식 컴포넌트도 기본적으로 함께 렌더링 됩니다.
 4. **컨텍스트 변경**: `useContext()` 훅을 통해 구독하고 있는 컨텍스트값이 변경될 때

 **조정자(Reconciler)**: 가상 DOM과 재조정 알고리즘을 담당하는 리액트의 뇌. 어떤 컴포넌트의 상태가 변경되면, 어떤 부분이 변겨오디어야 하는지 계산하는 역할
 **렌더러(Renderer)**: 조정자로부터 변경 사항을 전달받아, 실제 UI로 그려내는 손과 발.

 ### 애플리케이션이 처음 로드될 때

 애플리케이션의 모든 렌더링은 최초 렌더링에서 시작됩니다. 이는 `react-dom` 렌더러를 사용하여 리액트 애플리케이션을 실제 DOM에 연결할 때 발생합니다.

 ```jsx
 import ReactDOM from 'react-dom/client';

 ReactDOM>createRoot(document.getElementById('root')!).render(
    <StrictMode>
        <App />
    </StrictMode>,
 )
 ```

### 컴포넌트 내부 상태값의 변경으로 인한 리렌더링

컴포넌트는 각자 고유의 상태를 가지며, 이 상태가 변경될 때 UI를 업데이트하기 위해 리렌더링이 발생합니다.

#### 클래스 컴포넌트의 setState()

```jsx
class ClassCounter extends Component {
    constructor(props){
        super(props);
        this.state = { count: 0 };
    }
}

// 1. setState를 사용한 상태 업데이트
increment = () => {
    this.setState({ count: this.state.count + 1});
}


// 2. forceUpdate를 사용한 강제 리렌더링
forceUpdateComponent = () => {
    this.forceUpdate();
}
```

1. `this.setState()`가 호출되면 상태 업데이트가 예약되고, 리액트는 리렌더링을 계획합니다.
2. 클래스 컴포넌트에서는 내부 상탯값을 별도로 선언하지 않아도 프로그래밍적으로 강제 리렌더링을 시킬 수 있는 this.forceUpdate()메서드를 제공합니다. 이 메서드를 호출 시 클래스 컴포넌트는 강제로 리렌더링이 됩니다.

#### 함수형 컴포넌트의 seState()

```jsx
const FunctionCounter = () => {
    // 1. useState를 사용한 상태 관리
    const [count, setCount] = useState(0);

    // 2. useReducer를 사용한 상태 관리
    const [reducerState, dispatch] = useReducer(reducer, { count: 0 });

    // 3. 함수형 컴포넌트를 위한 올바른 forceUpdate 구현
    const [, setToggle] = useState(false);
    const forceUpdate = () => setToggle(prev => !prev);
}
```

1. `setCount()` 호출 시 count 상탯값의 업데이트가 예약되며 컴포넌트가 리렌더링됩니다.
2. `useReducer()`에서 반환하는 `dispatch()` 함수를 통해서 컴포넌트에서 선언한 상태를 reducer 내부에 선언한 각 조건에 따라 업데이트할 수 있습니다.
3. 함수형 컴포넌트에서는 forceUpdate() API가 공식적으로 존재하지 ㅇ낳기 때문에 useState()를 사용해야 합니다.


### 부모 컴포넌트가 리렌더링되었을 때

리액트에서 부모 컴포넌트가 리렌더링되면, 별도의 최적화 기법을 자식 컴포넌트에게 적용하지 않는 한 기본적으로 그 자식 컴포넌트들도 모두 리렌더링됩니다. 이는 자식에게 전달되는 프롭스가 변경되었는지 여부와 관계없이 일어나는 기본 동작입니다. 

```jsx
const Child = ({ value }) => {
    console.log(`Child 컴포넌트 렌더링 (value: ${value})`);
    return <div>Child (props: {value})</div>;
}

const Parent = () => {
    const [time, setTime] = useState(new Date());
    const [count, setCount] = useState(0)

    useEffect(() => {
        const interval = setInterval(() => {
            setTime(new Date());
        }, 1000);

        return () => clearInterval(interval);
    }, []);

    console.log('Parent 컴포넌트가 리렌더링되었습니다.');

    return (
        <div>
            <p>현재 시간: {time.toLocaleTimeString()}</p>

            <button onClick={() => setCount(count + 1)}>
                Count 증가 (자식 props 변경)
            </button>

            <Child value={count}>
            <MemoizedChild value={count}>
        </div>       
    )
}
```

- 일반 자식 컴포넌트인 Child는 부모인 `<Parent>` 가 리렌더링되고 value 프롭스가 바뀐 `<Child>`가 리렌더링됩니다.


### 컨텍스트의 값이 변경되었을 때

```jsx
const DisplayMood = () => {
    const { mood } = useContext(MoodContext);
    console.log('DisplayMood render');

    return (
        <div>
            { mood === 'Hppay' ? 'happy' : 'unhappy'}
        </div>
    );
};

const ToggleMoodButton = () => {
    const { changeMood } = useContext(MoodContext);
    console.log('ToggleMoodButton render');

    return (
        <button onClick={changedMood}>Toggle Mood</button>
    );
};

const App = () => {
    return (
        <MoodProvider>
            <div>
                <DisplayMood>
                <ToggleMoodButton>
            </div>
        </MoodProvider>
    );
};
```

1. `<MoodProvider>`라는 컨텍스트 제공자가 앱 전체를 감싸고 있으므로, 그 하위의 모든 컴포넌트는 컨텍스트값의 변경에 영향을 받을 수 있습니다.
2. `<DisplayMood>`와 `<ToggleMoodButton>` 컴포넌트는 App 컴포넌트로부터 어떠한 프롭스도 전달받지 않습니다. 하지만 이것만으ㅗㄹ 두 컴포넌트가 리렌더링되지 않을 것이라고 단정할 수는 없습니다.
3. `<DisplayMood>` 컴포넌트는 `useContext()`를 통해 `<MoodProvider>`가 제공하는 컨텍스트값을 구독합니다. 이처럼 컴포넌트는 프롭스나 내부 상태가 없어도, 컨텍스트에 의존하여 데이터를 받고 리렌더링될 수 있습니다.
4. mood값이 변경되면, 이 값을 직접 사용하는 DisplayMood 컴포넌트는 당연히 리렌더링되어 UI를 업데이트합니다.
5. `<ToggleMoodButton>` 컴포넌트 역시 `useContext()`로 `<MoodContext>`를 구독하지만 mood 상태가 아닌 `changeMood()`만을 사용하고 있습니다.

## 리렌더링에 대한 오해

### 자식 컴포넌트와 props.children

부모 컴포넌트가 리렌더링되면 그 안에 포함된 자식 컴포넌트들도 함께 리렌더링된다는 점은 이제 익숙한 사실입니다. 그렇다면 `props.children`으로 전달된 요소들 역시 부모가 리렌더링될 때마다 항상 함께 리렌더링될까요? 꼭 그렇지는 않습니디.

```jsx
const ChildComponent = () => {
    console.log('ChildComponent rendered');
    return <div>자식 컴포넌트</div>;
}

const Parent = ({ children }) => {
    const [count, setCount] = useState(0);
    console.log('Parent rendered');


    useEffect(() => {
        const interval = setInterval(() => setCount(c => c + 1), 1000);
        return () => clearInterval(interval);
    }, []);

    return (
        <div>
            // Case 1 일반 자식 컴포넌트
            <ChildComponent />

            // Case 2 children prop으로 전달된 컴포넌트
            {children}
        </div>
    );
}


const RenderChecker = () => {
    console.log('RendererChecker rerendered')
    return <div>props.children 컴포넌트</div>
}

const App = () => {
    <Parent>
        <RerenderChecker />
    </Parent>
}
```

해당 예제에서는 `<Parent>`와 `<ChildComponent>`는 1초마다 계속 렌더링되지만 RendererChecker는 초기 렌더링 이후 전혀 렌더링 되지 않습니다. 그 이유는 JSX가 변환한 결과물인 리액트 엘리먼트가 생성되는 시점과 위치 때문에 발생하기 때문입니다.

1. `<ChildComponent>` JSX는 `<Parent>` 컴포넌트의 return 문 내부에 있스빈다. 이는 Parent가 리렌더링될 때마다 매번 jsx() 혹은 React.createElement()가 호출되어 새로운 엘리먼트 객체가 생성된다는 의미입니다.

2. `<RerenderChecker>` JSX는 `<Parent>`보다 상위 스코프인 App 컴포넌트의 return문 내부에 있습니다. 컴포넌트는 최초 한 번만 렌더링됩니다. 이때 생성된 RerenderChecker 엘리먼트가 Parent에게는 props.children으로 전달됩니다.
`<Parent>`가 자신의 count 상태 때문에 리렌더링될 떄, `<App>`은 리렌더링되지 않습니다. 따라서 `<Parent>`가 받은 props.children은 이전 렌더링과 완벽하게 동일한 참조를 가진 객체입니다. 리액트는 자식은 변경되지 않았으니 렌더링을 건너뛰어도 되겠다고 판단하여 최적화를 수행합니다. 이처럼 props.children을 활용하는 것은 단순히 컴포넌트를 합성하는 기술을 넘어, 렌더링 스코프를 분리하여 불필요한 리렌더링을 방지하는 강력한 패턴입니다.

### 컴포넌트에 전달되는 프롭스값이 변경되었을 때

리액트에서는 부모 컴포넌트가 리렌더링될 때 자식 컴포넌트도 함께 리렌더링되는 것이 기본 동작입니다. 이 때문에 흔히 자식에게 전달되는 프롭스가 변경되는 것이 자식 컴포넌트를 리렌더링시키기는 트리거가 된다고 생각하기 쉽습니다. 

하지만 앞선 예제들에서도 확인했듯, 부모가 리렌더링되면 자식에게 전달되는 프롭스가 변경의 여부와 관계없이 자식은 기본적으로 리렌더링됩니다. 그렇다면 자식의 리렌더링을 유발하는 진짜 원인은 프롭스값의 변경일까요? 아니면 부모의 리렌더링 그 자체일까요?

```jsx
import React, { useState, useEffect, useRef } from 'react';

const StaticChild = () => {
    console.log("StaticChild가 리렌더링되었습니다.");
    return <div>Static Child</div>;
}

const Child = ({ value }) => {
    console.log(`Child가 리렌더링되었습니다. value: ${value}`);
    return <div>Child Value: { value }</div>;
}

const Parent = () => {
    const propRef = useRef({ value: 0 });

    useEffect(() => {
        const interval = setInterval(() => {
            propRef.current.value += 1;
            console.log('ref 값이 업데이트되었습니다.: ', propRef.current.value);
        }, 1000);
    return () => clearInterval(interval);
    }, [])

    console.log('Parent가 리렌더링되었습니다.');

    return(
        <div>
            <StaticChild />
            <Child value={propRef.current.value} />
        </div>
    )
}
```

실행 결과를 보면, 콘솔에서 1초마다 "ref 값이 업데이트되었습니다"라는 로그가 찍히지만, Child 컴포넌트의 `console.log()`는 초기 렌더링 이후 전혀 호출되지 않습니다. 화면에 보이는 Child Value 역시 0에서 멈추어 있습니다.

변경 사항이 콘솔 탭에 반영된 것을 보면 ref값은 1초에 한 번씩 수정되었으나 Child 컴포넌트의 글자는 변경되지 않은 것을 확인할 수 있습니다. 이렇게 ref의 값을 변경하여 props에 이미 바인딩한 값을 변경하는 상황은 매우 드물지만, 프롭스값의 변경 자체는 자식 컴포넌트의 리렌더링과 무관하다는 점을 알게 되었습니다.

Child 컴포넌트는 propRef의 값이 아무리 내부적으로 바뀌어도 그 사실을 알지 못합니다. Parent가 리렌더링되지 않았기 때문에, Child에게 새로운 프롭스를 전달하는 행위 자체가 일어나지 않은 겁니다.


## 리액트 렌더링 규칙

### 부수 효과 제거와 멱등성 보장

여타 부수 효과를 피하기 위해 작성하는 순수 함수와 같이 리액트 컴포넌트와 훅은 같은 조건에서 아무리 여러 번 렌더링되어도 항상 같은 결과를 화면에 만들어내는 멱등성(Idempotent)이 보장되어야 합니다.

```jsx
function useOnlineStatus(){
    return navigator.isOnline;
}
```

navigator 객체의 isOnline에 접근해 값을 반환하는 것으로, 리액트가 알지 못하는 인터넷 연결 여부에 따라 다른 값을 반환합니다. 따라서 멱등성을 보장하지 않습니다.

```jsx
import { useState } from 'react';
import axios from 'axios';

const items = [];

const SideEffectComponent = () => {
    const [state, setState] = useState("");

    console.log("Rendering...");

    const token = document.cookie.split('; ').find(row => row.startsWith('token='))?.split('=')[1]

    axios.get("/data");

    if(token){
        items.push(token);
    }

    const mainElement = document.getElementById("main");
    if (mainElement){
        const textNode = document.createTextNode("hi");
        mainElement.appendChild(textNode);
    }

    return (
        <div>Do not use side effects during rendering</div>
    )
};
```

1. **콘솔로깅**: 엄밀히 말해 브라우저의 콘솔 API라는 외부 시스템을 이용하는 부수 효과입니다. 하지만, 디버깅 목적의 console.log()는 직접적인 문제를 일으키지 않으므로 허용되는 예외적인 경우입니다.
2. **쿠키/저장소 접근**: 컴포넌트의 렌더링 결과가 외부 환경인 브라우저 저장소에 따라 달라지게 되므로 순수성이 깨집니다.
3. **상태 업데이트**: 렌더링 중에 `setState()`를 호출하여 즉시 또 다른 리렌더링이 예약됩니다. 이는 무한 렌더링 루프에 빠질 수 있는 매우 위험한 패턴입니다. 리액트는 개발 모드에서 이러한 동작에 대해 경고를 표시합니다.
4. **네트워크 요청**: 렌더링은 동기적으로 완료되어야 하는데, 비동기 작업인 네트워크 요청을 수행하면 렌더링 시점을 예측할 수 업섹 됩니다. 또한 응답값으로 어떤 값이 전달될지 불명확하기 때문에 명백한 부수효과입니다.
5. **외부 변수 변경**: 컴포넌트 외부의 변수를 수정하는 것은 다른 컴포넌트의 동자겡 영향을 줄 수 있으며, 애플리케이션 상태를 예측 불가능하게 만듭니다.
6. **직접적인 DOM 조작**: 렌더링 도중 개발자가 직접 DOM을 조작하면 리액트의 렌더링 매커니즘과 충돌하여 UI가 꺠질 수 있습니다.


### JSX로 전달된 값의 불변성을 유지

```jsx
function GoldenRabbitPageBad({ color }){
    const styles = { color, sparkles: ' ', size: 'large' };
    const rabbitHeader <RabbitHeader styles={styles} />;

    styles.size = 'small';

    return <RabbitContent header={rabbitHeader} styles={styles} />;
}

function GoldenRabbitPageGood({ color }){
    const headerStyles = {
        color,
        sparkles: 'emoji',
        size: 'large',
    }

    const rabbitHeader = <RabbitHeader styles={headerStyles} />;
    const contentStyles = {
        ...headerStyles,
        size: 'small'
    }

    return <RabbitContent header={rabbitHeader} styles={contentStyles} />;
}
```

1. headerStyles는 이미 RabbitHeader 컴포넌트에서 사용되었기 때문에 다음 라인에서 임의로 수정해서는 안됩니다. GoldenRabbitPageBad 컴포넌트에서는 styles 객체를 생성하여 RabbitHeader에 전달한 후, 같은 객체의 size 속성을 직접 변경했습니다. 이는 이미 JSX에 전달된 객체를 수정하는 잘못된 방식입니다. 이렇게 하면 RabbitHeader와 RabbitContent가 서로 다른 스타일 값을 가져야 함에도 불구하고, 같은 객체를 공유하게 되어 의도하지 않은 동작이 발생할 수 있습니다.


## 정리

**리렌더링의 세 가지 주요 원인**
1. 컴포넌트 자신의 상태가 변경될 때~
2. 부모 컴포넌트가 리렌더링될 때
3. 구독 중인 컨텍스트가 변경될 떄

**프롭스의 변경**: 자식 컴포넌트의 리렌더링을 유발하는 직접적인 원인은 프롭스값의 변경이 아니라 부모 컴포넌트의 리렌더링 그 자체입니다.


## 아하 모먼트
- props.children으로 받는 React.Node는 해당 컴포넌트가 리렌더링 된다고 해서 props.children은 리렌더링 되지 않는 것을 확인했습니다. 바깥에서 주입받은 데이터는 해당 컴포넌트가 감싸고 있다해서 리렌더링 대상이 되지 않습니다. 이러한 매커니즘은 리렌더링 최적화 기법에 큰 도움을 줄 수 있을 것 같습니다.

- 프롭스를 내린다고 해서 무조건 리렌더링 되지 않은 것을 확인했습니다. 이러한 상황이 매우 드물기 때문에 잘 인지하지 못했을 뿐 프롭스가 있어도 어쨋든 부모가 리렌더링되면서 자식도 리렌더링 되는 핵심을 다시한 번 파악했습니다.