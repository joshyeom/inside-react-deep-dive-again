## 렌더링

흔히 렌더링이라고 하면 UI가 화면에 그려지는 순간이라고 오해하는 경우가 많습니다. 하지만 리액트의 렌더링은 UI가 앞으로 어떻게 보일지 계산하는 과정을 의미합니다. 렌더링하는 동안 리액트는 함수형 컴포넌트라면 FunctionalComponent()를, 클래스 컴포넌트라면 ClassComponent.render()를 호출합니다. 이 함수들은 리액트가 렌더링 과정에서 호출하는 것이므로 개발자가 직접 호출해서는 안 됩니다.

각 함수형 컴포넌트 및 클래스 컴포넌트의 render()함수가 실행되면 내부에 선언해 둔 JSX가 반환됩니다. 빌드 과정을 통해 이 JSX는 jsx(), jsxs() 혹은 React.createElement() 같은 함수 호출로 변환되며, 이 함수들은 리액트 엘리먼트를 반환합니다. **즉, 렌더링이란 컴포넌트 함수를 호출해 리액트 엘리먼트를 생성하는 과정**이며, 실제 DOM을 변경하는 작업은 커밋 단계에서 일어납니다.

렌더링 과정은 Trigger, Render, Commit 세 단계로 나눌 수 있습니다. 최초 렌더링은 root.render()를 호출할 때 트리거되며, 이후의 리렌더링은 주로 useState()의 상태 설정 함수나 클래스 컴포넌트의 경우 this.setState() 호출을 통해 트리거됩니다.

리액트 18버전부터는 ReactDOM.createRoot()로 생성된 루트의 render() 메서드에 루트 컴포넌트를 전달하여 최초 렌더링을 트리거합니다. 이 때 render()의 인자로 전달되는 컴포넌트를 루트 컴포넌트라고 합니다.

```jsx
import { createRoot } from "react-dom/client";

createRoot(document.getElementById("root")).render(
  <StrictMode>
    <App />
  </StrictMode>
);
```

root.render() 호출은 렌더링 과정을 시작하라는 트리거 역할을 합니다. 리액트 공식 문서에서도 트리거는 렌더링의 첫 번째 단계로 설명합니다. 이것은 렌더링의 시작점이자 업데이트를 예약하는 과정입니다.

트리거를 통해 특정 컴포넌트의 렌더링이 시작되면, 마치 도미노의 첫 블록이 다음 블록을 쓰러트리듯 해당 컴포넌트의 모든 자식 컴포넌트들도 순차적으로 렌더링됩니다. 만약 도미노의 중간 블록을 쓰러트리면 그 이전 블록은 서 있고 뒤쪽 블록만 넘어지는 것처럼, 어느 컴포넌트에서 상태 업데이트가 발생했는지에 따라 애플리케이션의 일부만 리렌더링할지, 전체를 리렌더링할지가 결정됩니다.

컴포넌트 함수를 호출하여 화면에 표시될 UI 컴포넌트들을 만드는 단계를 렌더 단계(Render phase)라고 합니다. 이 과정은 실제 DOM을 조작하지 않으며, 메모리 상에서 새로운 가상 DOM을 계산할 뿐입니다. 리액트는 이 단계에서 생성된 새로운 가상 DOM과 이전 가상 DOM을 비교하여 변경이 필요한 부분을 찾아냅니다.

```jsx
import React, { useState, useEffect } from "react"; // 리액트 및 useState, useEffect 훅 임포트

// 함수형 컴포넌트 선언
function RenderPhaseExample() {
  // useState 훅을 사용하여 count 상태와 이를 업데이트하는 setCount 함수 선언
  // 초기값은 0
  const [count, setCount] = useState(0);

  // useEffect 훅을 사용하여 마운트 및 언마운트 시점 확인
  useEffect(() => {
    // --- 마운트 시점 ---
    // 컴포넌트가 처음 렌더링되어 DOM에 삽입된 후 실행됨
    // 의존성 배열이 비어있으므로([]) 마운트 시 한 번만 실행됨
    console.log("마운트: 컴포넌트가 DOM에 추가됨");

    // --- 언마운트 시점 (클린업 함수) ---
    // 컴포넌트가 DOM에서 제거되기 직전에 실행됨
    // 이벤트 리스너 제거, 타이머 해제 등 리소스 정리에 사용됨
    return () => {
      console.log("언마운트: 컴포넌트가 DOM에서 제거됨");
    };
  }, []); // 빈 의존성 배열: 마운트 시 1회 실행, 언마운트 시 클린업 실행

  // --- 렌더 단계 (Render Phase) 시작 ---
  // 컴포넌트 함수가 호출되는 것 자체가 렌더 단계의 시작임
  // 여기서는 상태 변경 시 이전 가상돔과 비교할 새로운 가상돔을 계산함
  // 실제 DOM 변경은 아직 발생하지 않음
  console.log("렌더 단계 실행: 가상돔 계산 중...");

  // 상태를 업데이트하는 함수 (렌더링 트리거 역할)
  const handleIncrement = () => {
    // setCount가 호출되면 리액트는 이 컴포넌트의 리렌더링을 예약(스케줄링)함
    // 이것이 렌더링을 유발하는 '트리거'가 됨
    setCount((prevCount) => prevCount + 1);
  };

  // 렌더 단계의 결과물: JSX (리액트 엘리먼트) 반환
  // 이 JSX는 리액트에 의해 가상돔으로 변환됨
  return (
    <div>
      <h1>카운터: {count}</h1>
      <p>버튼을 클릭하면 상태가 업데이트되어 리렌더링이 발생합니다.</p>
      {/* 버튼 클릭 시 handleIncrement 함수 호출 */}
      <button onClick={handleIncrement}>증가</button>
    </div>
  );
  // --- 렌더 단계 (Render Phase) 종료 ---
}

export default RenderPhaseExample; // 다른 파일에서 사용 가능하도록 컴포넌트 내보내기
```

## 언마운트

개발자가 직접 DOM을 좆가하고 싶다면 리액트 엘리먼트를 통해 만든 가상 DOM이 처음으로 실제 DOM 노드로 만든 이후부터 가능합니다. useEffect() 생명주기 함수의 콜백 함수는 컴포넌트가 마운트된 직후 호출됩니다. 따라서 DOM을 직접 조작하고 싶다면 useEffect()의 콜백 함수를 사용해야 합니다. 만든 컴포넌트가 화면에서 더 이상 나타날 필요가 없을 때 리액트는 전체 가상 DOM의 트리에서 해당 컴포넌트를 제거합니다. 이 때 컴포넌트가 **언마운트**되었다고 합니다.

이벤트 핸들러를 부착하거나 웹소켓을 연결하는 일들이 마운트 시점에 이뤄진다면, 언마운트 시점에는 반대로 이벤트 핸들러를 제거하고 컴포넌트가 화면에 나타나는 동안 사용했던 리소스를 해제하는 일들을 할 수 있습니다. 리액트 컴포넌트는 한 앱에서 여러 번 호출될 수 있기 때문에 마운트 시점에 등록한 이벤트 핸들러나 다른 리소스가 있다면 언마운트될 때 놓치지 말고 해제해야 메모리 누수를 방지할 수 있습니다.

## 리렌더링

프롭스가 전달되거나 내부 상탯값이 변경됨에 따라 화면을 변경해야 할 때는 **리렌더링** 과정을 거치게 됩니다. 리렌더링은 이미 마운트된 컴포넌트의 함수를 다시 호출하여 새로운 리액트 엘리먼트 트리를 생성하는 과정으로 리액트 이전에 렌더링된 가상 DOM과 새로 생성된 가상 DOM일 비교하여 변경된 부분만 실제 DOM에 반영합니다. 리렌더링에서는 이미 만든 리액트 엘리먼트를 재사용할 뿐만 아니라 리액트 엘리먼트를 통해 이미 만든 실제 DOM 노드에서 최소한의 부분만 변경되기 때문에 마운트와 비교했을 때 훨씬 가벼운 작업이라고 할 수 있습니다.

## 커밋

변경된 가상 DOM의 결과를 실제 DOM에 적용하고 화면에 반영하는 단계를 커밋 단계라고 합니다. 이 단계에서는 리액트가 필요한 DOM의 업데이트를 수행하며 이 과정은 일괄적으로 이뤄집니다. 리액트 18버전부터 업데이트의 자동 배칭(Batching)이 일반화되어 여러 상태 업데이트가 발생해도 리액트는 똑똑하게 한 번의 커밋으로 처리합니다.

렌더 단계에서 생성된 가상 DOM과 이전 가상 DOM의 비교가 끝나고 실제 변경이 필요하다고 판단될 때 시작됩니다. 즉, 렌더 과정이 일어난다고 꼭 커밋 단계까 따라 발생하는 것이 아닙니다.

리액트가 계산된 변경사항을 실제 DOM에 적용합니다. 이 시점에 브라우저 화면이 갱신됩니다. DOM 업데이트가 완료된 후, useEffect(), useLayoutEffect() 훅의 콜백 함수가 실행됩니다. 이 단계에서는 DOM에 접근하거나, 데이터를 가져오거나, 구독을 설정하는 등의 부수 효과를 수행하는 것이 안전합니다.

## 재조정 과정 (Reconciliation)

리액트가 화면을 효율적으로 업데이트하는 핵심 원리는 가상 DOM의 재조정 과정에 있습니다. 이 과정에서 리액트는 이전 가상 DOM과 새로운 가상 DOM을 비교하여 실제로 변경이 필요한 부분만 선별해 최소한으로 업데이트합니다.

두 개의 일반적인 트리를 비교하여 최소한의 차이를 찾는 알고리즘의 시간 복잡도는 O(n3)이 걸립니다. 만약 1000개의 노드를 가진 트리를 비교한다면 최악의 경우 10억 번의 비교 연산이 필요할 수 있습니다. 이는 UI를 더 빠르게 만들려다 오히려 성능을 해치는 결과를 낳습니다. 이 문제를 해결하기 위해 리액트는 두 가지 실용적인 휴리스틱 가정에 기반한 O(n)복잡도의 재조정 알고르짐을 구현했습니다.

1. **서로 다른 타입의 엘리먼트는 다른 트리를 구축한다**: 만약 <h1>이 <h2>로 바뀌거나 컴포넌트가 바뀐다면 리액트는 두 컴포넌트가 완전히 다르다고 가정하고 이전 트리를 통째로 버리고 새로운 트리를 처음부터 구축합니다.
2. **개발자가 키 프롭스를 통해, 여러 렌더링 사이에서 어떤 자식 엘리먼트가 그대로 유지되어야 하는지 표시해줄 수 있다.**: 자식 엘리먼트 배열을 비교할 때, 리액트는 기본적으로 순서대로 비교합니다. 하지만 리스트 맨 앞에 새로운 엘리먼트가 추가되면, 모든 자식이 변경되었다고 오해하여 비효율적인 업데이트를 할 수 있습니다. 이 때 key props를 사용하면, 리액트는 키를 통해 이전 트리와 새로운 트리의 자식들을 효율적으로 매칭하여 쵯호나의 변경(삽입, 이동, 삭제) 만을 수행합니다.

### Fiber

파이버는 리액트가 렌더링 작업을 처리하는 기본 단위를 말합니다. 화면을 구성하는 각 엘리먼트는 내부적으로 자신만의 파이버 객체를 갖습니다. 이 객체는 해당 엘리먼트에 어떤 변경(생성, 업데이트, 삭제)이 필요한지, 작업의 우선순위는 무엇인지, 그리고 다른 파이버인부모, 자식, 형제 엘리먼트와의 관계는 어떻게 되는지에 대한 정보가 모두 담겨 있습니다. 리액트의 재조정은 이 파이버트리를 바탕으로 렌더 단계와 커밋 단계 두 단계로 나뉘어 진행됩니다.

렌더 단계의 목표는 변경점을 계산하는 것으로 현재 파이버 트리와 새로운 리액트 엘리먼트(컴포넌트 함수의 반환값)를 비교하여 어떤 DOM 변경이 필요한지 계산하고, 파이버에 표시하는 겁니다. 이 단계에서는 실제 DOM을 변경하지 않습니다. 리액트는 파이버 트리를 순회하며 각 노드에 대해 beginWork() 함수를 호출합니다. 이 함수는 렌더 단계에서 각 파이버를 처리하는 시작점이며, 파이버의 타입에 따라 각기 다른 업데이트 함수를 실행합니다. 함수형 컴포넌트의 경우 renderWithHooks()가 호출되어 컴포넌트 함수를 실행합니다. 이 과정에서 useState(), useEffect(), useMemo()와 같은 훅들이 실행됩니다. 만약 처리할 파이버에 업데이트와 컨텍스트 변경사항이 없으면 조기 종료(bailout)합니다.

```jsx
function updateElement(returnFiber, current, element, lanes) {
  // 타입 비교 (및 키 비교)
  if (current !== null && current.elementType === element.type) {
    // 타입 일치 -> 기존 Fiber 재사용 결정
    const workInProgress = useFiber(current, element.props); // stateNode, ref 등 상속
    workInProgress.return = returnFiber;
    // ... 기타 설정 ...
    return workInProgress; // 재사용할 Fiber 반환
  } else {
    // 타입 불일치 -> 기존 Fiber 삭제하고 새로 생성 (createFiberFromElement 호출)
    // ...
  }
}

function useFiber(fiber, pendingProps) {
  const clone = createWorkInProgress(fiber, pendingProps);
  // clone은 fiber의 stateNode, ref, type 등을 물려받음
  clone.index = 0;
  clone.sibling = null;
  return clone;
}

function updateFunctionComponent(
  current,
  workInProgress,
  Component,
  nextProps,
  renderLanes
) {
  // 1. Context 준비 (Context API 값 읽기 준비)
  prepareToReadContext(workInProgress, renderLanes);

  let nextChildren;
  let hasScheduledUpdateOrContext = false; // 컴포넌트 자체 업데이트나 context 변경 여부

  // (DEV 환경) 개발 관련 유효성 검사 등 수행...
  validateFunctionComponentInDev(workInProgress, Component);

  // (최적화) 만약 이전 파이버가 있고, 업데이트가 없다면 Bailout 시도
  // (주의: React.memo 비교는 updateMemoComponent에서 이미 처리됨.
  //  여기서는 주로 context 변경이나 부모로부터의 강제 업데이트 등을 확인)
  if (current !== null) {
    hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(
      current,
      renderLanes
    );
    if (
      !hasScheduledUpdateOrContext &&
      (workInProgress.flags & DidCapture) === NoFlags
    ) {
      // 특별한 업데이트가 없고, 이전에 에러/Suspense도 없었다면 Bailout 가능성 있음
      // (실제로는 Hooks 상태 변경 등 내부 요인도 고려되어 renderWithHooks에서 최종 결정됨)
      // 만약 여기서 Bailout 조건이 확실하다면 bailoutOnAlreadyFinishedWork 호출 가능
      // (실제 코드에서는 renderWithHooks 호출 후 결과 보고 Bailout 결정하는 경우가 많음)
    }
  }

  // 2. 컴포넌트 함수 실행 (Hooks 처리 포함)
  //    - renderWithHooks가 핵심! 이 안에서 useState, useEffect, useMemo 등 모든 Hook 실행
  //    - Component(nextProps, secondArg) 형태로 함수 호출
  nextChildren = renderWithHooks(
    current, // 이전 파이버 (Hook 상태 복원 등에 사용)
    workInProgress, // 현재 작업 중인 파이버
    Component, // 실행할 함수 컴포넌트
    nextProps, // 새로운 props
    null, // context (레거시)
    renderLanes // 현재 렌더링 레인
  );

  // (renderWithHooks 내부에서didReceiveUpdate 플래그가 설정될 수 있음 - Hooks 상태 변경 등)
  if (current !== null && !didReceiveUpdate && !hasScheduledUpdateOrContext) {
    // Hooks 상태 변경도 없고, 외부 업데이트 요인도 없다면 최종 Bailout
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  }

  // 3. 컴포넌트 실행 결과(자식들) 재조정
  //   **  - renderWithHooks가 반환한 nextChildren과 이전 자식 파이버(current.child) 비교 ** //NOTE - 재조정 알고리즘이 실제로 동작하는 부분 ( 디핑 알고리즘 )
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);

  // 4. 첫 번째 자식 파이버 반환 (다음 작업 대상)
  return workInProgress.child;
}

function updateHostComponent(current, workInProgress, renderLanes) {
  const oldProps = current.memoizedProps;
  const newProps = workInProgress.pendingProps;

  // Props 비교하여 차이점 계산
  const updatePayload = diffProperties(
    domElement, // workInProgress.stateNode
    workInProgress.type,
    oldProps,
    newProps
    // ...
  );

  // 변경 사항이 있으면 updatePayload 저장 및 Update 플래그 설정
  if (updatePayload) {
    workInProgress.updateQueue = updatePayload;
    workInProgress.flags |= Update; // Update 플래그 추가!
  }

  // ... 자식 재조정 (reconcileChildren 호출) ...
  return workInProgress.child;
}

function commitUpdate(
  domElement, // fiber.stateNode
  updatePayload, // fiber.updateQueue
  type,
  oldProps,
  newProps,
  internalInstanceHandle
) {
  // 1. updatePayload를 순회하며 실제 DOM 속성 업데이트
  for (let i = 0; i < updatePayload.length; i += 2) {
    const propKey = updatePayload[i];
    const propValue = updatePayload[i + 1];
    if (propKey === "style") {
      // style 업데이트 로직
    } else if (propKey === "className") {
      domElement.className = propValue;
    } else {
      // 기타 속성 업데이트 (setAttribute 등)
    }
  }
}

// 단일 자식 비교 의사코드 (reconcileSingleElement 로직 기반)
function reconcileSingleElement(returnFiber, currentFirstChild, newElement) {
  let oldFiber = currentFirstChild;

  // 이전 자식 파이버들을 순회하며 비교 시도
  while (oldFiber !== null) {
    // 1. Key 우선 비교 (엘리먼트 key와 파이버 key)
    if (oldFiber.key === newElement.key) {
      // 2. Key 일치 시 Type 비교 (엘리먼트 type과 파이버 elementType)
      if (oldFiber.elementType === newElement.type) {
        // 3. Key와 Type 모두 일치 -> 재사용!
        //    남은 형제들은 불필요하므로 삭제 대상으로 표시
        deleteRemainingChildren(returnFiber, oldFiber.sibling);
        //    기존 파이버를 기반으로 workInProgress 파이버 생성 (stateNode 등 상속)
        const existing = useFiber(oldFiber, newElement.props);
        existing.return = returnFiber;
        //    재사용한 파이버 반환
        return existing;
      } else {
        // Key는 같지만 Type이 다름 -> 재사용 불가!
        // 현재 oldFiber 및 이후 모든 형제 삭제 대상으로 표시
        deleteRemainingChildren(returnFiber, oldFiber);
        // 비교 중단 (더 이상 일치 가능성 없음)
        break;
      }
    } else {
      // Key 불일치 -> 현재 oldFiber는 삭제 대상으로 표시
      deleteChild(returnFiber, oldFiber);
    }
    // 다음 형제 파이버로 이동하여 비교 계속
    oldFiber = oldFiber.sibling;
  }

  // 루프 종료 후: 일치하는 파이버를 찾지 못했거나, Type 불일치로 중단된 경우
  // 새로운 엘리먼트를 위한 새 파이버 생성
  const created = createFiberFromElement(newElement, returnFiber.mode, lanes);
  created.return = returnFiber;
  // 생성된 새 파이버 반환
  return created;
}

// 여러 자식 비교 의사코드 (reconcileChildrenArray 로직 기반)
function reconcileChildrenArray(
  returnFiber,
  currentFirstChild,
  newChildrenArray
) {
  let resultingFirstChild = null; // 새로 만들어질 자식 파이버 리스트의 첫 번째
  let previousNewFiber = null; // 리스트 연결을 위한 이전 파이버 포인터
  let oldFiber = currentFirstChild; // 비교 대상인 이전 자식 파이버
  let newIdx = 0; // 새 자식 배열의 현재 인덱스
  let lastPlacedIndex = 0; // 이동(Move) 감지를 위한 이전 인덱스 추적

  // (간략화) 1단계: 앞에서부터 순서대로 비교하며 최대한 재사용
  // Key와 Type이 일치하는 동안 oldFiber와 newChildrenArray[newIdx]를 비교하며 재사용
  // ... (실제 코드는 더 복잡하지만, 기본 아이디어는 동일) ...

  // (간략화) 2단계: 남은 요소들 처리 (Key 기반 매칭)

  // 2a. 남은 기존 자식들을 Key를 키로 하는 Map으로 변환
  const existingChildrenMap = mapRemainingChildren(oldFiber);

  // 2b. 남은 새 자식 배열을 순회
  for (; newIdx < newChildrenArray.length; newIdx++) {
    const newChildElement = newChildrenArray[newIdx];
    const key = newChildElement.key !== null ? newChildElement.key : newIdx;
    let newFiber = null;

    // 2c. Map에서 Key로 기존 파이버 검색
    const matchedOldFiber = existingChildrenMap.get(key);

    if (matchedOldFiber !== undefined) {
      // Key 일치! -> Type 비교
      if (matchedOldFiber.elementType === newChildElement.type) {
        // Type까지 일치 -> 재사용!
        newFiber = useFiber(matchedOldFiber, newChildElement.props);
        // Map에서 제거 (처리 완료)
        existingChildrenMap.delete(key);

        // ** 이동(Move) 감지 **
        // 기존 위치(matchedOldFiber.index)가 마지막 배치 위치보다 작으면 이동 필요
        if (matchedOldFiber.index < lastPlacedIndex) {
          newFiber.flags |= Placement; // Placement 플래그 설정
        }
        lastPlacedIndex = Math.max(lastPlacedIndex, matchedOldFiber.index);
      } else {
        // Key는 같지만 Type이 다름 -> 재사용 불가!
        // 기존 파이버는 삭제, 새 파이버 생성
        deleteChild(returnFiber, matchedOldFiber);
        existingChildrenMap.delete(key); // Map에서도 제거
        newFiber = createFiber(newChildElement);
        newFiber.flags |= Placement; // 새로 생성 시 항상 Placement
      }
    } else {
      // Key 불일치 -> 새 파이버 생성
      newFiber = createFiber(newChildElement);
      newFiber.flags |= Placement; // 새로 생성 시 항상 Placement
    }

    // 새로 생성/재사용된 파이버를 리스트에 연결
    newFiber.return = returnFiber;
    if (previousNewFiber === null) {
      resultingFirstChild = newFiber;
    } else {
      previousNewFiber.sibling = newFiber;
    }
    previousNewFiber = newFiber;
  }

  // 2d. Map에 아직 남아있는 기존 자식들은 더 이상 불필요 -> 모두 삭제
  existingChildrenMap.forEach((child) => deleteChild(returnFiber, child));

  // 완성된 자식 파이버 리스트의 첫 번째 반환
  return resultingFirstChild;
}

// --- 보조 함수 의사코드 ---
function useFiber(fiber, pendingProps) {
  // 기존 파이버(fiber)를 기반으로 workInProgress 파이버를 복제/생성
  const clone = createWorkInProgress(fiber, pendingProps);
  // stateNode, ref, type 등 주요 속성 상속
  clone.index = 0; // 형제 리스트 내 인덱스 초기화
  clone.sibling = null; // 형제 포인터 초기화
  return clone;
}

function createFiber(element) {
  // 주어진 React 엘리먼트로 새로운 파이버 객체 생성
  // ...
}

function deleteChild(returnFiber, childToDelete) {
  // 주어진 파이버(childToDelete)를 삭제 대상으로 표시
  // returnFiber.deletions 배열에 추가하고 ChildDeletion 플래그 설정
  // ...
}

function mapRemainingChildren(firstChild) {
  // 주어진 첫 번째 자식 파이버부터 형제들을 순회하며
  // Key(없으면 index)를 키로, 파이버를 값으로 하는 Map 생성하여 반환
  // ...
}

function reconcileChildrenArray(
  returnFiber,
  currentFirstChild,
  newChildrenArray
) {
  // 1. 이전 자식들을 식별 정보(Key 또는 Index) 기반 Map으로 생성
  const oldFiberMap = mapOldFibersByIdentifier(currentFirstChild);

  let resultingFirstChild = null;
  let previousNewFiber = null;
  let lastPlacedIndex = -1; // 이동 감지용

  // 2. 새로운 자식 배열 순회
  for (let newIdx = 0; newIdx < newChildrenArray.length; newIdx++) {
    const newElement = newChildrenArray[newIdx];
    if (newElement === null) continue; // null은 건너뜀

    // 3. 새 엘리먼트의 식별 정보 결정 (Key 우선, 없으면 Index)
    const identifier = newElement.key !== null ? newElement.key : newIdx;

    // 4. 식별 정보(identifier)를 사용해 Map에서 이전 파이버 검색
    const matchedOldFiber = oldFiberMap.get(identifier);

    let newFiber;

    if (matchedOldFiber) {
      // 5a. 식별 정보 일치! -> Map에서 제거하고 Type 비교
      oldFiberMap.delete(identifier);
      if (matchedOldFiber.elementType === newElement.type) {
        // Type까지 일치 -> 재사용
        newFiber = useFiber(matchedOldFiber, newElement.props);
        // 이동 여부 판단 (기존 인덱스와 현재 배치 순서 비교)
        if (matchedOldFiber.index < lastPlacedIndex) {
          newFiber.flags |= Placement; // 이동 필요
        }
        lastPlacedIndex = Math.max(lastPlacedIndex, matchedOldFiber.index);
      } else {
        // Type 불일치 -> 기존 것 삭제, 새 것 생성
        deleteChild(returnFiber, matchedOldFiber);
        newFiber = createFiber(newElement);
        newFiber.flags |= Placement; // 생성은 항상 배치
      }
    } else {
      // 5b. 식별 정보 불일치 -> 새 파이버 생성
      newFiber = createFiber(newElement);
      newFiber.flags |= Placement; // 생성은 항상 배치
    }

    // 생성/재사용된 파이버 연결
    newFiber.return = returnFiber;
    if (previousNewFiber === null) {
      resultingFirstChild = newFiber;
    } else {
      previousNewFiber.sibling = newFiber;
    }
    previousNewFiber = newFiber;
  }

  // 6. Map에 남은 이전 파이버들은 모두 삭제
  oldFiberMap.forEach((fiber) => deleteChild(returnFiber, fiber));

  return resultingFirstChild;
}
```

리액트는 key를 사용해 엘리먼트의 고유한 정체성을 식별합니다. key가 같다면 리액트는 재사용을 시도합니다. 하지만 key가 없거나 변경되면, 리액트는 완전히 새로운 엘리먼트로 간주하여 기존 상태와 DOM을 버리고 새로 만듭니다. 이것이 리스트 렌더링 시 key를 인덱스로 사용하면 예기치 않은 버그가 발생하는 이유입니다.

```jsx
import { useState } from "react";
import Input from "./Input";

const First = () => {
  const [disabled, setDisabled] = useState(false);
  const toggle = () => {
    setDisabled(!disabled);
  };
  return (
    <div>
      <button onClick={toggle}>toggle disable</button>
      {/* 조건부 렌더링 */}
      {disabled ? (
        <Input disabled name="disabled-input" />
      ) : (
        <Input name="active-input" />
      )}
    </div>
  );
};

// -----

import { useState } from "react";
import Input from "./Input";

const Second = () => {
  const [disabled, setDisabled] = useState(false);
  const toggle = () => {
    setDisabled(!disabled);
  };
  return (
    <div>
      <button onClick={toggle}>toggle disable</button>
      {disabled ? <Input disabled name="disabled-input" /> : null}
      {!disabled ? <Input name="active-input" /> : null}
    </div>
  );
};
```

First는 Input 컴포넌트가 **업데이트**되고 Second는 Input 컴포넌트가 **리렌더링**됩니다.

그 이유는 재조정 조건에 의해 First 컴포넌트에서는 같은 위치에 element가 type과 key가 동일한 반면, Second는 같은 위치에 element가 Input과 null로 타입이 다르기 때문에 항상 렌더링 됩니다.

### 재조정 마무리

beginWork()가 트리를 아래로 탐색하며 각 파이버에서 할 일을 시작하고 자식들을 비교했다면, completeWork()는 반대로 트리를 위로 거슬러 올라가며 각 파이버의 작업을 마무리합니다. completeWork() 의 역할은 다음과 같습니다.

1. **DOM 노드 생성 및 준비**: beginWork() 단계에서 생성(Placement) 플래그가 붙은 파이버를 위해 실제 DOM 노드 인스턴스륾 만들고 초기 프롭스를 설정합니다.
2. **자식 DOM 노드 연결 준비**: 현재 파이버의 자식 DOM 노드들을 현재 파이버의 DOM 노드에 추가하는 작업을 준비합니다. 실제 조작은 커밋 단계에서 이루어집니다.
3. **변경 사항 전파**: 현재 파이버에서 발생한 작업 플래그들을 부모 파이버로 전파합니다.

이 과정이 트리 루트까지 반복되면 최종적으로 루트 파이버에서는 실제 DOM에 적용해야 할 모든 작업 목록들이 연결됩니다. 이렇게 beginWork()와 completeWork()를 통해 파이버 트리 전체를 순회하는 렌더 단계가 끝나면, 리액트는 두 개의 결과물을 갖게 됩니다.

1. **작업 진행 중 파이버 트리 WIP(Work-IN Progress tree)**: 화면에 렌더링될 새로운 트리를 모두 반영하는 완성된 파이버 트리입니다. 이 트리는 잠시 후 현재 트리가 될 준비를 마쳤습니다.
2. **작업 목록(이펙트 리스트, effectList)**: 렌더 단계 동안 기록된 생성, 이동, 재사용(업데이트), 삭제 작업 플래그를 기반으로 만들어진, 실제 DOM에 적용해야 할 작업들의 연결 리스트입니다. 이 리스트는 어떤 노드를 추가하거나 텍스트를 업데이트해야 할지, 또는 어떤 노드를 삭제해야 하는지와 같은 구체적인 지시 사항의 모음입니다. 이 리스트는 루트 파이버의 firstEffect, lastEffect 필드를 통해 연결되어 있습니다.

렌더 단계가 끝나고 이펙트 리스트가 완성되면, 리액트는 커밋 단계로 넘어갑니다. 이 단계는 계산된 변경 사항을 실제 DOM에 적용하여 새로운 UI를 보여주는 마지막 과정입니다. 커밋 단계는 동기적으로 실행되며, 중간에 중단될 수 없습니다. 그 이유는 유저가 불완전하거나 일관성 없는 UI를 보내는 것을 방지하기 위함입니다.

```jsx
function commitUpdate(
  domElement, // 업데이트할 실제 DOM 노드 (fiber.stateNode)
  updatePayload, // ➊ 적용할 속성 변경 목록 ['className', 'new-class', 'style', newStyleObject]와 같이 키와 값 쌍으로 이루어져 있어, 어떤 속성을 어떤 값으로 바꿔야 하는지에 대한 구체적인 지시를 담고 있음
  type,
  oldProps,
  newProps,
  internalInstanceHandle
) {
  // ➋ 변경 목록을 순회하며 실제 DOM 속성을 업데이트
  for (let i = 0; i < updatePayload.length; i += 2) {
    const propKey = updatePayload[i];
    const propValue = updatePayload[i + 1];

    if (propKey === "style") {
      // style 객체를 비교하여 변경된 부분만 적용
      updateStyle(domElement, propValue);
    } else if (propKey === "className") {
      domElement.className = propValue;
    } else if (propKey === "children") {
      // 텍스트 자식 노드 업데이트
      domElement.textContent = propValue;
    } else {
      // 기타 속성 업데이트 (setAttribute 등)
      domElement.setAttribute(propKey, propValue);
    }
  }
}
```

## 얕은 비교

React.memo()로 감싸진 함수형 컴포넌트나 클래스형 PureComponent의 경우, 리액트는 본격적인 렌더링에 앞서 프롭스에 대한 얕은 비교를 수행합니다. 이 비교 결과 변경 사항이 없다고 판단되면, 리액트는 해당 컴포넌트의 렌더링 함수 실행을 건너뛸 뿐만 아니라, 그 하위 트리 전체에 대한 재조정 과정까지 모두 생략합니다. 이는 상당한 성능 향상을 가져올 수 있습니다. 얕은 비교는 객체의 모든 중첩된 속성까지 재귀적으로 확인하는 깊은 비교와 대조됩니다.

```jsx
function updateSimpleMemoComponent(
  current,
  workInProgress,
  Component,
  nextProps,
  renderLanes
) {
  // ... (함수 시작 및 초기 검사) ...
  if (current !== null) {
    const prevProps = current.memoizedProps; // 이전 props 가져오기
    // Compare new props with previous props
    // ==============================================================
    // =====> 실제 얕은 비교가 일어나는 부분 <=====
    // ==============================================================
    // shared/shallowEqual.js 에 정의된 shallowEqual 함수를 사용
    if (
      shallowEqual(prevProps, nextProps) && // *** shallowEqual 호출! ***
      current.ref === workInProgress.ref &&
      workInProgress.type === current.type // Assume same type is sufficient for memo
    ) {
      didReceiveUpdate = false;
      workInProgress.pendingProps = nextProps;
      // 다른 업데이트(context 변경 등)가 없는지 추가 확인
      if (!checkScheduledUpdateOrContext(current, renderLanes)) {
        // 변경 없음 & 다른 업데이트 없음 -> Bailout!
        workInProgress.lanes = current.lanes;
        return bailoutOnAlreadyFinishedWork(
          current,
          workInProgress,
          renderLanes
        );
      }
      // ... (강제 업데이트 처리) ...
    }
  }

  return updateFunctionComponent(
    current,
    workInProgress,
    Component,
    nextProps,
    renderLanes
  );
}

function shallowCompare(objA, objB) {
  // 동일 참조 또는 동일 원시값 확인 (가장 빠른 비교)
  // (JavaScript의 Object.is 와 유사한 동작)
  if (objA === objB || (objA !== objA && objB !== objB)) {
    // NaN 처리 포함
    return true; // 참조가 같거나 원시값이 같으면 동일
  }

  // 둘 중 하나라도 객체/배열이 아니거나 null이면 다른 것, 타입 확인
  if (
    typeof objA !== "object" ||
    objA === null ||
    typeof objB !== "object" ||
    objB === null
  ) {
    return false;
  }

  // 객체/배열의 키(속성) 목록 가져오기
  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);

  // 키의 개수 비교
  if (keysA.length !== keysB.length) {
    return false; // 키 개수가 다르면 다른 객체
  }

  // 각 키에 대해 값 비교 (주의: 값 자체의 참조만 비교!)
  for (let i = 0; i < keysA.length; i++) {
    const key = keysA[i];
    // objB에 해당 key가 없거나,
    // 해당 key에 대한 값의 참조(또는 원시값)가 다르면 false
    // (값 자체가 객체나 배열일 경우, 그 내부까지 비교하지 않음!) => 얕은 비교라고 불리는 이유
    if (!objB.hasOwnProperty(key) || objA[key] !== objB[key]) {
      // (실제로는 원시값 비교를 위해 Object.is 사용 권장)
      return false;
    }
  }

  // 모든 키의 값이 얕게 비교했을 때 동일하면 true
  return true;
}
```

React.memo(), useEffect(), useMemo(), useCallback() 훅의 의존성 배열을 비교할 때도 내부적으로 얕은 비교 로직이 사용됩니다. 모든 컴포넌트에 기본적으로 얕은 비교가 적용되는 것은 아닙니다. 부모가 리렌더링되면 프롭스의 변경 여부와 관계없이 항상 함께 리렌더링됩니다. React.memo()는 프롭스에 대한 얕은 비교를 통과했을 때만 렌더링을 건너뛰게 합니다.

## key props

key는 리액트가 리스트에 있는 항목을 식별하는 데 사용하는 특별한 프롭스입니다. 같은 리스트 내의 엘리먼트들은 서로 구분할 수 있는 고유한 키를 가져야 합니다. 키는 재조정 과정에서 리액트의 디핑 알고리즘이 효율적으로 동작하도록 돕는 핵심적인 역할을 합니다.

```jsx
import React, { useEffect, useState } from "react";

// 토끼 이름 카드 컴포넌트 (실험용)
export const RabbitNameCard = ({ name }) => {
  useEffect(() => {
    // ➊ 이 컴포넌트 인스턴스가 생성(마운트)될 때 한 번만 실행됨
    console.log(`Card "${name}" mounted`);
    return () => console.log(`Card "${name}" unmounted`);
  }, []);

  // ➋ 이 컴포넌트가 리렌더링 될 때마다 실행됨
  useEffect(() => {
    console.log(`Card "${name}" rerendered with new props`);
  });

  // ➌ defaultValue는 오직 마운트 시점에만 input의 초기값을 설정함
  return (
    <input
      defaultValue={name}
      className="border border-gray-300 p-2 rounded text-center shadow-sm"
    />
  );
};

// 토끼 이름 배열을 섞는 Fisher-Yates 알고리즘 구현 함수
const shuffle = (rabbits = []) => {
  /* ... 이전 코드와 동일 ... */
};

const RabbitShuffleDeck = () => {
  const initialRabbits = [
    "Golden",
    "Silver",
    "Dante",
    "Frank",
    "Kate",
    "Bread",
  ];
  const [rabbitDeck, setRabbitDeck] = useState(initialRabbits);

  const handleClick = () => {
    setRabbitDeck(shuffle(initialRabbits));
  };

  return (
    <div className="p-4 flex flex-col items-center gap-y-4">
      <button onClick={handleClick} className="...">
        shuffle rabbit
      </button>
      <div className="grid grid-cols-3 gap-2 w-full max-w-md">
        {/* key 프롭 없이 리스트를 렌더링 */}
        {rabbitDeck.map((rabbit) => (
          <RabbitNameCard name={rabbit} />
        ))}
      </div>
    </div>
  );
};

export default RabbitShuffleDeck;
```

현재 코드는 rabbitDeck 배열을 순회하며 <RabbitNameCard>를 렌더링할 때, 가장 중요한 key props를 누락했습니다. 실행하고 셔플 버튼을 누르면 콘솔에서는 rabbitDeck 배열의 순서가 바뀌는 것을 확인할 수 있지만, 화면의 <input>값들은 전혀 바뀌지 않는 것처럼 보입니다.

키가 없으면 리액트는 배열의 인덱스를 기본 키로 사용합니다. 위 코드를 실행하면 리액트는 다음과 같이 생각합니다.

1. 이전 렌더링의 [index: 0] 위치의 컴포넌트 타입은 "RabbitNameCard"였고, 프롭스는 {name: "Golden"}이었으나 리렌더링 시 [index: 0]의 컴포넌트 타입은 "RabbitNameCard"이고 프롭스만 {name: "Bread"}로 바뀌었구나
2. 같은 위치에 같은 타입의 컴포넌트가 있으니, 동일한 컴포넌트로 보고 재사용해야겠다.

컴포넌트를 이동시키지 않고, 제자리에 그대로 둔 채 프롭스만 업데이트 하게 됩니다. <RabbitNameCard>는 새로운 name 프롭스를 받아 리렌더링되지만 defaultValue는 오직 마운트 시에만 작동하므로 이미 화면에 그려진 <input>의 값은 바뀌지 않습니다. useEffect()콜백 함수에 작성한 로그가 다시 출력되지 않는 것이 그 증거입니다.

key에 고유한 값을 할당하게 되면 리액트는 key를 보고 각 카드를 정확히 식별합니다. 리액트는 이제 컴포넌트를 재상요하는 대신, 각 컴포넌트를 올바른 위치로 이동시킵니다. 컴포넌트가 그대로 유지된 채 위치만 바뀌므로, <input>에 담긴 내부 상태(유저가 입력한 값 등)도 그대로 보존됩니다.

이런 이유로, 데이터의 순서가 바뀌거나 필터링되거나, 항목이 추가/삭제 될 수 있는 모든 리스트 렌더링에서 배열 인덱스를 키로 사용하는 것은 매우 위험하며 안티 패턴으로 간주됩니다.

## 메모이제이션

각 카드의 순서가 올바르게 변경되었지만, <RabbitNameCard> 컴포넌트는 순서만 바뀌었을 뿐 각 카드의 내용인 name props는 변하지 않았으므로 이 렌더링은 불필요한 작업입니다. React.memo()를 사용해 이런 불필요한 리렌더링을 막을 수 있습니다.

```jsx
const MemoizedNameCard = React.memo(RabbitNameCard);

const MemoizedCardDisplay = React.memo(RabbitNameDisplay);

// React.memo로 컴포넌트를 감싸서 메모이제이션
const MemoizedCardDisplay = React.memo(RabbitNameDisplay);

// ... 컴포넌트 내부 ...
// 인덱스를 key로 사용
rabbitDeck.map((rabbit, index) => (
  <MemoizedCardDisplay name={rabbit} key={index} />
));
```

하지만 React.memo()도 키를 잘못 사용하면 무용지물이 됩니다. 인덱스를 키로 사용하면 이 최적화는 동작하지 않고 그대로 다시 리렌더링 됩니다. 다음은 리렌더링을 하게 될 때, 리액트의 프로세스입니다.

1. 이전 렌더링에서 key={0}인 엘리먼트의 프롭스는 {name: "Golden"}이었다.
2. 새로운 렌더링에서 key={0}인 엘리먼트의 프롭스는 {name: "Silver"}이다.
3. 얕은 비교 수행 시 결과가 false이므로 프롭스가 변경되었다.
4. 따라서 MemoizedCardDisplay는 리렌더링 되어야 한다.

## 아하 모먼트

Fiber와 재조정을 통해 리렌더링을 유발하는 방식으로 개발을 했던 것을 알 수 있었습니다. 특히, First, Second의 예시로 정확하게 파악할 수 있었고 무분별한 리렌더링을 막기 위해 항상 type과 key 관리에 신경을 써야겠다고 생각이 들었습니다.

리액트가 UI를 그리는 과정을 다시한번 훑고 머리에 그릴 수 있게 되었습니다. 전체적인 렌더링 과정은 다음과 같습니다.

JSX 작성
↓
트리거 발동 (setState, props 변경 등)
↓
createElement()로 React Element 생성
↓
React Element를 보고 Fiber 노드를 하나씩 생성
↓
동시에 이전 Fiber 노드(current)와 비교 (Diffing)
├─ type 비교
├─ key 비교  
 └─ effectTag 표시 (mount/update/unmount)
↓
(여기까지 Render Phase - 중단 가능)
↓
work-in-progress 트리 완성
↓
Commit Phase (중단 불가)
└─ effectTag에 따라 실제 DOM 반영
├─ mount: DOM 생성
├─ update: DOM 수정
└─ unmount: DOM 제거

얕은 비교는 React.memo()로 감쌋을 때 리렌더링 될지 재사용할지를 정하는 과정
