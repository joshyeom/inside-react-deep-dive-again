## 웹 개발

웹 개발은 HTTP 통신을 활용해 클라이언트와 서버간의 정보를 주고받는 인터페이스들을 만들어줍니다.

클라이언트: Browser로 제공되는 HTML/CSS/JS를 서버에서 받아와서 렌더링합니다.

서버: 클라이언트의 요청에 대해 DB에서 데이터를 조회/수정/삭제를 해줍니다.. 이를 API형태로 제공합니다.

DB: 데이터를 저장합니다.

## MPA

초기의 웹 페이지는 비동기로 데이터를 불러오지 못해서 새로운 페이지를 다시 웹 서버에 요청해서 클라이언트가 다시 받는 방식을 택했습니다. 이를 MPA(Multi Page Application)이라고 합니다.

## 모듈

MPA는 반복되는 코드들을 많이 생성했습니다. 이 때문에, 유지보수가 어려워졌습니다. 이를 해결하기 위해 코드조각을 만들어 서로 공유하게했습니다. 이로써 JS모듈이 탄생했습니다.

## 번들러

이번에는 모듈이 많아지면서 문제가 발생했습니다. 모듈끼리 서로간의 영향을 미친는 의존성이 발생했습니다. 예를 들어, jQuery의 DatePicker 컴포넌트는 스크립트가 순서대로 동작해야해서 모듈을 5개 순서대로 지정해야했습니다.

이러한 문제를 해결하기 위해 번들러가 등장했습니다. 번들러는 원하는 라이브러리만 요청하여 의존성을 해결하고 트리 쉐이킹을 자동으로 해줘서 메모리 손실을 줄여줍니다.

## NPM

개발자들은 라이브러리를 사용하려면 해당 라이브러리 웹 페이지를 방문하여 다운로드를 받아야했습니다. NPM은 외부 라이브러리를 프로젝트에 따로 저장하지 않고, 스크립트 한줄로 라이브러리를 다운 받을 수 있게 되었고, package.json에 명세가 있기 때문에 언제든지 다시 다운로드 받을 수 있게 되었습니다.

## 템플릿 엔진

반복되는 HTML 코드와 동적인 컨텐츠를 효율적으로 관리하기 위해 템플릿 엔진이 개발되었습니다. 템플릿 엔진은 서버에서 조건문 등과 같은 자바스크립트 문법을 사용해 HTML을 동적으로 생성하고, 완성된 HTML을 브라우저에 전달합니다.

이후 src, public, dist, node_modules와 같은 폴더 구조가 널리 퍼지게 되었습니다.

## 명령형 / 선언형

사용자의 인터렉션이 복잡해짐에 따라 모든 요소를 일일이 변경시키는 것이 보수가 굉장히 많이 드는 작업이 되어버렸습니다.

이전에는 명령형으로 일일이 DOM을 추적하고 변경해주어야 했지만, React와 같은 프레임워크의 등장으로 선언형 프로그래밍이 가능해졌습니다. 선언형 프로그래밍은 알고리즘과 구현은 프레임워크가 진행하고 개발자는 목표에 집중할 수 있게 되었습니다.

---

## 아하 모먼트

기술의 발전과 한계를 순서대로 설명해주어 지금의 방식까지 어떠한 시행착오가 있었는지 알 수 있게 되었습니다.

또한, 지금의 방식도 언제든지 바뀔 수 있다는 유연한 사고 방식이 필요하다고 깨달았습니다.
