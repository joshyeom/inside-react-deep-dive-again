## 개발환경이 중요한 이유

프로젝트의 성공 여부는 단순히 코드의 질이 아닌, 그 코드가 작성되고, 테스트되고, 빌드되는 전체과정, 즉 개발환경의 견고함에 달려있습니다.

특히 Node.js나 패키지 매니저와 같은 근간을 이루는 기술에 대한 이해 없이 여러 도구를 사용하다 보면, 문제 해결 능력이나 시스템 설계 역량을 키우는 데 한계에 부딪히기 쉽습니다.

## Node.js

Node.js는 C/C++ 언어로 작성된 V8 자바스크립트 엔진을 기반으로 빌드된, 서버와 같은 브라우저 밖 환경에서 자바스크립트 코드를 실행하는 런타임 환경입니다.

## 노드 버전 매니저

NVM을 사용하면 간단한 명령어로 특정 버전의 Node.js를 설치, 삭제하고 프로젝트에 맞는 버전으로 손쉽게 전환할 수 있어, 독립적이고 일관된 개발 환경을 유지할 수 있습니다.

`nvm list` 명령어를 사용해 현재 컴퓨터에 설치된 노드 버전을 열람할 수 있습니다.

`nvm use 18.16.1` 이런 명령어를 사용하지 않아도 기본적으로 커맨드라인 인터페이스에서 사용하는 노드 버전을 지정하려면 다음과 같이 alias를 사용하면 됩니다. `nvm alias default 18.16.1`

Node.js 버전을 팀원들이 다 같은 환경에서 사용하도록 강제하여 버전 호환성을 유지하는 것이 중요합니다.

```
# .nvmrc 파일 내용
20.14.0
```

## 패키지 매니저

패키지 매니저는 앱을 실행하는 데 필요한 패키지들을 관리하는 역할을 합니다.

개발자가 개별 라이브러리들을 수동으로 내려받지 않도록 `package.json`에 각 라이브러리의 버전을 명시한 후 각 패키지 매니저에서 제공하는 설치 명령어를 통해 한 번에 내려 받을 수 있습니다.

### lock 파일

lock 파일들은 현재 프로젝트에 설치된 모든 패키지의 정확한 버전과 그 하위 의존성들의 전체 트리가 기록됩니다. 이를 통해 항상 같은 버전 패키지들이 설치되는 것을 보장합니다.

### 유령 의존성

`package.json`에 명시되어 있지 않은 의존성 모듈을 코드에서 직접 참조하는 경우를 의미합니다.

A 패키지가 B 패키지를 의존성으로 가지고 있는 경우 최상위 `node_modules`에 A, B가 모두 설치되어 의도와는 다르게 B 모듈을 참조하는 코드를 사용할 수 있습니다.

pnpm과 yarn은 각각 심볼릭 링크와 PnP 방식을 통해 이런 의존성 문제를 해결할 수 있습니다.

#### 심볼릭 링크

파일 시스템 레벨에서 다른 파일/폴더를 가리키는 참조를 일컫습니다.

#### PnP

Plug n Play 약자로 node_modules를 제거하고 yarn/cache에 의존성을 zip파일로 관리합니다.

## 모노레포

모노레포는 여러 프로젝트 혹은 패키지들을 하나의 저장소에서 관리할 수 있는 전략입니다.

여러 앱이 사용하는 라이브러리 코드를 한 저장소에서 같이 관리할 수 있습니다.

모노레포 환경에서는 기존 저장소에 새로운 프로젝트를 쉽게 생성할 수 있어 빌드 설정이나 CI/CD 파이프라인에서 참조하는 코드가 명확히 구획화 되어 있어, 개발자가 개발에 더욱 집중할 수 있습니다.

## 코드 퀄리티와 코드 포매팅

현업에서 빌드 성능만큼 중요한 것은 다른 팀원들과 일관된 코드로 작성하는 겁니다. 코드의 스타일만 달라져도 유지 보수에 큰 어려움이 생기기 떄문입니다.

### 린터 (Eslint)

린터는 코드 퀄리티 검사기로서 미리 정의해둔 룰을 준수하지 않고 올바르지 않게 작성된 코드를 찾아냅니다. 린터는 커스터마이징할 수 있는데 스타일 관련 규칙까지 포함할 수 있습니다.

하지만, 스타일 규칙은 린터의 역할이 아니기에 포매터와 같이 사용할 경우 충돌로 올바르게 기능하지 못할 수 있습니다.

예를 들어 eslint-plugin-prettier 플러그인을 사용해 코드 퀄리티 검사를 수행할 때 프리티어 규칙을 Eslint에 통합해 스타일 오류 또한 IDE에 표시할 수 있는데 이는 포매터와 린터를 별도로 사용했을 때와 비교해 훨씬 느린 속도로 린터를 수행하게 만드는 잘못된 사용입니다.

### 포매터 (Prettier)

코드의 형태를 일관되게 유지하는 것을 의미합니다. 린터와 다르게 논리적인 에러가 있는지 확인해주지 않습니다.

### 코드 정적 분석기 (뭐가있지?)

원격 저장소에 포함된 코드 중 린터 규칙을 지키지 않거나 테스트 커버리지를 달성하지 못한 변경점이 있으면 개발자에게 이를 알려주는 역할을 합니다.

## 리액트 개발 환경과 빌드 도구

리액트 애플리케이션은 ES 모듈, JSX, TS, SCSS를 사용하기 떄문에 브라우저가 바로 이해할 수 없어 빌드 도구의 도움을 받아 번들링과 트랜스파일링을 수행하고, 성능 향상을 위해 미니파이를 진행해서 여러 브라우저에게 호환되는 산출물로 만들어야 합니다.

### CRA

웹팩 기반으로 만든 도구입니다. 트랜스 파일링의 바벨, 타입스크립트 플러그인 등 초기에는 이런개발 환경설정을 대신했지만, 라우터, 코드 스플리팅, 빌드 설정 커스타마이징을 제공하지 않았고 최신 빌드 툴에 비해 빌드 속도가 떨어지는 점들 때문에 deprecated 되었습니다.

### VITE

개발 서버를 완전히 종료 후 재가동 시키는 것을 콜드스타트라고 하는데 비트는 웹팩과 비교해 굉장히 빠릅니다.

비트는 개발 전체에서 전체 애플리케이션을 번들링할 필요가 없이 브라우저에서 실제로 요청하는 필요한 파일들만 ES 모듈로 불러 사용할 수 있게 합니다.

비트는 개발 서버에서 사전 번들링을 수행할 때 GO 언어로 작성된 ESbuild를 사용하며 이는 사전 번들링을 매우 빠른 속도로 가능하게 도와줍니다.

### RSbuild

러스트로 작성된 빌드 도구로 RSpack 번들러를 제공하빈다. 웹팩과 마찬가지로 JSX/TSX를 트랜스파일 해주기 위해 여러 플러그인을 설치하고 로더 설정을 해야하나 RSbuild를 사용하면 이런 과정을 생략할 수 있어 웹팩 마이그레이션에 용이합니다.

## 아하 모먼트

- 노드 버전을 통일 시키는 방법을 익힐 수 있었습니다.
- 유령의존성과 해결하는 방법을 익힐 수 있었습니다.
- WebPack, Vite의 차이와 빌드 도구의 역할을 익힐 수 있었습니다.

### 유령의존성이란?

package.json에 명세되어 있지 않은 모듈을 import할 수 있는 의존성입니다. 이는 npm으로 설치하면서 의존 모듈을 설치하는 과정중에 생긴 문제로, 폴더 구조가 평탄화 되어 있기 때문에 발생한 문제입니다.

```
node_modules/
├── react/
└── scheduler/  ← react의 의존성인데 최상위에 존재
```

이를 해결하기위해 pnpm은 중첩 라우팅과 심벌릭 링크를 통해 폴더 구조를 평탄화시키지 않고 상위 폴더로 탐색할 수 있게끔 하여 유령 의존성을 해결했습니다.

yarn berry는 PnP(Plug)방식으로 node_modules를 대신 yarn/cache로 zip파일로 의존성을 관리합니다. 또한, pnp.cjs로 경로를 맵핑하여 더욱 빠르게 모듈을 찾을 수 있습니다.

### Vite는 왜 WebPack보다 빠른가?

기존에 사용되던 WebPack 번들러는 모듈 간 의존성을 파악해 한 파일로 묶는 번들링 방식을 사용했습니다. 왜냐하면 브라우저가 모듈을 불러오는 구문들을 읽을 수 없었기 때문입니다. 하지만, 브라우저가 ESM을 제공하기 시작하면서 Vite는 파일들을 한 파일로 묶을 필요 없이 ESM 그대로 번들링을 할 수 있게 되었습니다. 덕분에 콜드 스타트가 굉장히 빨라질 수 있었습니다.
