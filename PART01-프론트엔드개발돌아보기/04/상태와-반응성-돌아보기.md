도구를 단순한 유저의 시선이 아닌 설계자의 입장에서 숨겨진 원리를 이해하려는 노력을 하지 않는다면, 우리는 영원히 도구의 유저 수준에 머무를 수 밖에 없습니다.

상태와 반응성의 본질을 깊이 있게 탐구한다면, 나의 코드가 시스템 내에서 어떤 연쇄 작용을 일으킬지 예측할 수 있는 힘을 기를 수 있습니다. 이는 버그가 발생한 뒤에 수동적인 개발이 아니라, 무넺가 발생할 여지를 차단하는 능동적이고 견고한 코드를 작성하는 기반이 됩니다. 또한 더 나은 아키텍처를 설계하는 능력을 갖추게 도와줍니다.

## 서버 상태

주로 데이터베이스의 원시 데이터를 기반으로 비즈니스 로직에 따라 가공된 상태입니다. 유저의 정보, 게시글 목록 등이 이에 해당하며 서버 API 응답을 통해 클라이언트에 전달됩니다.

## 클라이언트 상태

API 요청으로 받은 유저 목록 등 서버로부터 받은 데이터를 화면에 표시하기 위해 사용되거나 모달의 열림/닫힘 여부와 같이 UI와 직접적인 상호작용을 위해 사용됩니다.

## 디자인 패턴

상태라는 개념 없이 유저의 모든 인터랙션에 대응해 DOM을 직접 선택하고 수정하는 명령형 방식으로 UI를 개발한다면 코드의 복잡도는 기하급수적으로 증가할겁니다. 로직 코드와 DOM 조작 코드가 뒤섞여 유지보수 또한 매우 어려워집니다.

이런 문제점을 해결하고 복잡한 UI 로직과 데이터를 효과적으로 관리하기 위해 등장한 것이 바로 디자인 패턴입니다.

디자인 패턴은 애플리케이션을 더 읽기 쉽고 유지보수하기 좋은 골조로 설계하는 방법을 제시하는 검증된 해법입니다.

## VIEW

프레젠테이션 레이어라고도 불리며, 유저가 화면에서 보고 직접 상호작용하는 모든 것을 책임집니다. 즉, UI를 화면에 렌더링하고 유저의 입력을 받아내는 것, 최전선에 위차하는 인터페이스가 뷰의 핵심 역할입니다.

- **바닐라 자바스크립트**: 정적 HTML이 UI의 기본 골격을 형성하고, DOM API를 직접 호출하는 자바스크립트 코드가 동적 UI 업데이트를 담당하며 뷰의 역할을 수행합니다.
- **리액트**: JSX로 작성된 선언적인 UI 컴포는터가 뷰에 해당합니다.
- **Vue.js**: <template> 구문을 사용하는 선언적인 UI 컴포넌트가 뷰의 역할을 합니다.

## Model

애플리케이션의 데이터와 그 데이터를 처리하는 비즈니스 로직을 모두 포함하는 부분으로 , 애플리케이션에서 화면을 표시하는데이터의 원천 역할을 수행합니다.

- **프론트엔드**: 클라이언트 상태와 그 상태를 관리하는 로직이 모델에 해당합니다.
- **백엔드**: 데이터베이스 스키마, ORM 객체 등이 모델의 역할을 합니다.

좀 더 자세히 나누자면 크게 2가지로 나눌 수 있습니다.

1. 데이터 관리: 애플리케이션의 핵심 데이터를 보유하고 관리합니다.
2. 비즈니스 로직: 애플리케이션의 고유한 규칙과 정책을 코드로써 실행합니다.

## Mediator

아키텍처에서는 뷰는 모델의 존재를, 모델은 뷰의 존재를 직접 알아서는 안 됩니다. 이런 관심사의 분리 원칙을 지킬 떄 시스템의 유연성과 확장성이 극대화되는데, 이 둘을 이어주는 것이 Controller(중재자)입니다.

이 중재자는 어떤 디자인 패턴을 사용하는지에 따라 각기 다른 이름으로 불리는데,

- MVC 패턴에서는 컨트롤러(Controller)
- MVP 패턴에서는 프레젠터(Presenter)
- MVVM 패턴에서는 뷰모델(ViewModel)
- Flux 아키텍처에서는 액션과 스토어의 조합을 통한 단방향 파이프라인 구성

## MVC 패턴 바닐라자바스크립트로 구현

### View

```js
export class TodoView {
  constructor() {
    // View로 보여줄 요소들 생성
    this.app = document.getElementById("app");
    this.todoList = document.createElement("ul");
    this.input = document.createElement("input");
    this.addButton = document.createElement("button");
    this.addButton.textContent = "Add";

    this.app.appendChild(this.input);
    this.app.appendChild(this.addButton);
    this.app.appendChild(this.todoList);
  }

  renderTodos(todos) {
    this.todoList.innerHTML = "";
    todos.forEach((todo, index) => {
      const listItem = document.createElement("li");
      listItem.textContent = todo;

      const deleteButton = document.createElement("button");
      deleteButton.textContent = "Delete";
      deleteButton.dataset.index = index;

      listItem.appendChild(deleteButton);
      this.todoList.appendChild(listItem);
    });
  }
}
```

### Model

```js
export class TodoModel {
  constructor() {
    this.todos = []; // todo 배열을 초기화
  }

  addTodo(todo) {
    this.todos.push(todo); // todo 리스트를 추가
  }

  removeTodo(index) {
    this.todos.splice(index, 1); // todo 리스트 제거
  }

  getTodos() {
    return this.todos; // todo 리스트 반환
  }
}
```

### Controller

```js
export class TodoController {
  constructor(model, view) {
    this.model = model;
    this.view = view;

    // 추가 버튼생성 및 바인딩
    this.view.addButton.addEventListener(
      "click",
      this.handleAddTodo.bind(this)
    );

    // 삭제 버튼 생성 및 바인딩
    this.view.todoList.addEventListener(
      "click",
      this.handleDeleteTodo.bind(this)
    );

    // 상태 변화 시 업데이트
    this.updateView();
  }

  // add 시 비즈니스로직
  handleAddTodo() {
    const todoText = this.view.input.value.trim();
    if (todoText) {
      this.model.addTodo(todoText);
      this.updateView();
      this.view.input.value = "";
    }
  }

  // delete 시 비즈니스 로직
  handleDeleteTodo(event) {
    if (event.target.tagName === "BUTTON") {
      const index = parseInt(event.target.dataset.index, 10);
      this.model.removeTodo(index);
      this.updateView();
    }
  }

  // update 시 비즈니스 로직
  updateView() {
    const todos = this.model.getTodos();
    this.view.renderTodos(todos);
  }
}
```

이렇게 작성되면, 요소 생성부터 바인딩, 이벤트 바인딩 등 명령형으로 일일이 지정할 일이 많아집니다.

## MVC 패턴에 반응성 주입하기

이전 MVP 패턴은 컨트롤러가 직접 뷰 업데이트 함수를 불러와야 했습니다. 이를 자동으로 반응성을 주입하여 해결할 수 있습니다.

뷰는 이전 코드와 동일합니다.

### Model

```js
export class TodoModel {
  constructor() {
    this.todos = [];
    // 구독하는 요소들의 배열
    this.listeners = [];
  }

  // 구독 요소를 추가하는 함수
  subscribe(listener) {
    this.listeners.push(listener);
  }

  // 구독 요소들에게 알림을 주는 함수
  notify() {
    this.listeners.forEach((listener) => listener(this.todos));
  }

  // 투두 리스트 추가
  addTodo(todo) {
    this.todos.push(todo);
    this.notify();
  }

  // 투두 리스트 삭제
  removeTodo(index) {
    this.todos.splice(index, 1);
    this.notify();
  }

  // 투두 리스트 반환
  getTodos() {
    return this.todos;
  }
}
```

### Controller

```js
export class TodoController {
  constructor(model, view) {
    this.model = model;
    this.view = view;

    // 투두리스트들을 구독 등록 후 render
    this.model.subscribe((todos) => {
      this.view.renderTodos(todos);
    });

    this.view.addButton.addEventListener(
      "click",
      this.handleAddTodo.bind(this)
    );
    this.view.todoList.addEventListener(
      "click",
      this.handleDeleteTodo.bind(this)
    );

    // 투두 리스트 반환 및 초기화
    this.view.renderTodos(this.model.getTodos());
  }

  handleAddTodo() {
    const todoText = this.view.input.value.trim();
    if (todoText) {
      this.model.addTodo(todoText);
      this.view.input.value = "";
    }
  }

  handleDeleteTodo(event) {
    if (event.target.tagName === "BUTTON") {
      const index = parseInt(event.target.dataset.index, 10);
      this.model.removeTodo(index);
    }
  }

  // update 로직이 사라짐
}
```

## 관찰자 패턴

앞서 MVC 패턴에 반응성을 추가하기 위해 사용했던 구조가 바로 관찰자 패턴입니다. 이 패턴은 발행-구독- 패턴 모델로 설명하기도 하는데, 주요 참여자인 발행자, 구독자로 구성됩니다.

- **발행자**: 관찰의 대상이 되는 객체로, 자신의 상태 변화를 외부에 알릴 책임이 있습니다. 앞선 예제에서는 TodoModel이 발행자 역할을 했습니다. 발행자는 자신을 구독한 구독자들의 목록을 유지합니다.
- **구독자**: 발행자의 상태 변화에 관심이 있어 그 변화를 통지받고 싶어하는 객체입니다. 앞선 예제에서는 컨트롤러가 등록한 뷰를 렌더링하는 콜백 함수가 구독자 역할을 했습니다.

이 패턴의 강점은 일대다(One-to-Many) 관계를 매우 효율적으로 관리할 수 있다는 점입니다.

관찰자 패턴을 구현하는 발행자는 일반적으로 세 가지 핵심 인터페이스를 제공해야 합니다.

- **Subscribe**: 구독을 신청하는 메서드
- **Notify**: 등록된 모든 구독자에게 변경 사실을 알리는 메서드
- **Unsubscribe**: 구독을 취소하는 메서드

## MVVM(Model-View-ViewModel) 패턴

이 패턴의 핵심은 유저 인터페이스와 데이터 및 비즈니스 로직의 분리를 유지하되, 그 사이를 뷰모델이라는 특별한 중재자를 통해 연결하는데 있습니다.

![](https://github.com/user-attachments/assets/b95473a6-d927-4735-859c-cc2e3792320f)

이런 구조 덕분에 개발자는 더 이상 DOM을 직접 제어하는 코드를 작성할 필요가 없어집니다.

### 단방향 바인딩

데이터가 한쪽 방향, 즉 뷰모델에서 뷰로만 흐릅니다. 뷰모델의 상태가 변경되면 뷰의 UI가 자동으로 업데이트 됩니다. 하지만 뷰에서 발생한 변경이 뷰모델의 상태를 자동으로 변경하지는 않습니다.

리액트는 단방향 바인딩을 기본 철학으로 채택한 대표적인 라이브러리입니다. 우리가 useState()로 상태를 만들고 value 속성으로 UI에 연결한 뒤, onChange()핸들러로 상태를 업데이트하는 코드를 작성하는 이유가 바로 이 때문입니다.

단방향 바인딩에서 데이터는 항상 모델에서 뷰로 흐르기 때문에 상태 변경은 이벤트 핸들러를 통해서만 명시저긍로 발생합니다.

### 양방향 바인딩

양항뱡 바인딩은 데이터가 양쪽, 뷰모델/ 뷰 사이를 자유롭게 흐릅니다. 뷰 모델의 상태 변경이 뷰에 반영되는 것은 물론, 뷰에서 발생한 변경 또한 자동으로 상태를 업데이트합니다.

프레임워크가 내부적으로 이벤트 핸들러 로직을 숨기고, 개발자를 대신해 처리하는 것과 같습니다.

## MVVM 패턴을 적용한 할 일 리스트 작성하기

### 뷰 모델

```html

<body>
  <div id="app">
    <h2>Todo List (MVVM Example)</h2>

    // input을 바인딩 합니다.
    <input
      type="text"
      data-bind="newTodo"
      placeholder="Enter a new todo..."
    />

    // 버튼을 바인딩 합니다.
    <button data-click="addTodo">Add Todo</button>

    <ul data-list="todos"></ul>
  </div>

  <script type="module" src="./todo.js"></script>
</body>
</html>
```

### 뷰모델

```js
export class ViewModel {
  constructor() {
    // 인스턴스 초기 상태
    this.observers = [];
    this.newTodo = "";
    this.todos = [];
  }

  // 구독 상태 판별 함수
  subscribe(callback) {
    this.observers.push(callback);
  }

  // 상태가 변했음을 알리는 함수
  notify(property, value) {
    this.observers.forEach((cb) => cb(property, value));
  }

  // setter함수
  set(property, value) {
    this[property] = value;
    this.notify(property, value);
  }

  // getter함수
  get(property) {
    return this[property];
  }

  // todo 추가
  addTodo() {
    const text = this.newTodo.trim();
    if (text) {
      this.todos.push(text);
      this.notify("todos", this.todos);
      this.set("newTodo", "");
    }
  }

  // todo 삭제
  removeTodo(index) {
    this.todos.splice(index, 1);
    this.notify("todos", this.todos);
  }
}
```

### 바인딩

```js
export function bindViewModel(viewModel, root) {
  // data-bind를 갖고 있는 input을 가져오기
  const boundInputs = root.querySelectorAll("[data-bind]");

  // data-bind의 속성 가져오기
  boundInputs.forEach((inputEl) => {
    const property = inputEl.getAttribute("data-bind");

    // input value에 viewModal에서 가져온 get을 넣어주기
    inputEl.value = viewModel.get(property) || "";

    // 값이 변할 경우 input에 데이터 넣어주기
    inputEl.addEventListener("input", (e) => {
      viewModel.set(property, e.target.value);
    });

    //
    viewModel.subscribe((changedProp, newValue) => {
      if (changedProp === property && inputEl.value !== newValue) {
        inputEl.value = newValue;
      }
    });
  });

  const clickableEls = root.querySelectorAll("[data-click]");
  clickableEls.forEach((clickEl) => {
    const methodName = clickEl.getAttribute("data-click");

    clickEl.addEventListener("click", () => {
      if (typeof viewModel[methodName] === "function") {
        viewModel[methodName]();
      }
    });
  });

  const listEls = root.querySelectorAll("[data-list]");
  listEls.forEach((listEl) => {
    const property = listEl.getAttribute("data-list");

    const renderList = (items) => {
      listEl.innerHTML = "";
      items.forEach((item, index) => {
        const li = document.createElement("li");
        li.textContent = item;

        const removeBtn = document.createElement("button");
        removeBtn.textContent = "삭제";
        removeBtn.style.marginLeft = "8px";
        removeBtn.addEventListener("click", () => {
          viewModel.removeTodo(index);
        });

        li.appendChild(removeBtn);
        listEl.appendChild(li);
      });
    };

    renderList(viewModel.get(property) || []);

    viewModel.subscribe((changedProp, newValue) => {
      if (changedProp === property) {
        renderList(newValue);
      }
    });
  });
}
```

### 컨트롤러

```js
import { ViewModel } from "./ViewModel.js";
import { bindViewModel } from "./binder.js";

const vm = new ViewModel();
const rootElement = document.getElementById("app");
bindViewModel(vm, rootElement);
vm.set("todos", ["양방향 바인딩 구현하기", "단방향 바인딩 공부하기"]);
```

이러렇게 모던 프레임워크와 유사하게 동작하는 반응형 애플리케이션을 만들 수 있습니다.

이제 ViewModel의 상태만 변경하면, 뷰는 별도의 DOM 조작 코드 없이 자동으로 업데이트됩니다. 이처럼 선언적 프로그래밍과 반응성을 직접 구현하려면, 바인더와 같이 보이지 않는 곳에서 동작하는 복잡한 보일러플레이트 코드를 미리 작성하고 그 내부 구조를 깊게 이해해야 합니다.

이런 어려움과 복잡성 떄문에 대부분의 현업 프로젝트에서는 리액트와 같이 고유의 아키텍처를 제공하는 잘 설계된 라이브러리나 프레임워크를 도입합니다.

## 아하 모먼트

MVC와 MVVM의 차이 및 원리를 이해할 수 있었습니다.

리액트를 사용하는 것은 나쁘지 않지만, 오롯이 리액트만 익혀서 단편적인 시야만 갖게되는 경우가 나쁜 케이스인 것을 알게 되었습니다.

바닐라 자바스크립트로 먼저 구현을 해보면 리액트에서 어떻게 선언적으로 구현할지가 조금씩 예상이 됩니다. 바닐라 자바스크립트로 구현해보는 연습이 필요하다고 느꼈습니다.
